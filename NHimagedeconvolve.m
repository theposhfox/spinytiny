function [Proc_Image LabelMat] = NHimagedeconvolve(Image, initial_PSF, routed, GaussFilt_size, MedFilt_size, MinBlob, MaxBlob)
%Function uses blind deconvolution to process an image, using an
%intial estimated PSF size. The returned PSF from the deconvolution process
%is then used to refine the image further. The function also reduces
%processing around edges (areas of high contrast) to minimize ringing). 
% For more information, all of these steps are included on the matlab help
% page for 'Deblurring with the Blind Deconvolution Algorithm'
% 'Image' should be an image generated by 'imread'
% 'Initial PSF' should be a 2d matrix with a size that estimates the PSF of
% the microscope (can be generated with the 'ones' command, as values don't
% initially matter)
% 'routed' signifies whether this function was called as a stand-alone or
% was rather routed through another program (so that figure generation can
% be supressed).

global gui_SpineSegmentation

h = waitbar(0, 'Processing');
steps = 8;
pauseopt = 0;

Im = uint16(Image); 
    
frames = size(Im,3); %%% Check if there are multiple time series images

if routed == 1 && frames > 1
    currentframe = get(gui_SpineSegmentation.handles.TimeCourse_Slider, 'Value');
else
    currentframe = 1;
end
if routed == 0
    counts = [];
    x  = [];
    pos = [];
    [counts, x] = imhist(Im(:,:,currentframe), 65535);
    [~, pos] = max(counts);
    sub1 = 3; sub2= 3;
    figure; subplot(sub1,sub2,1); imshow(Im, [pos 200]); title('Original Image');
else
end


%% Blind deconvolution 1 %%

waitbar(1/steps, h, 'Running blind deconvolution 1...');

se1 = strel('disk', 1);             %%% Created a structured element for image dilation

for i = 1:frames
    Im(:,:,i) = medfilt2(Im(:,:,i), [MedFilt_size MedFilt_size]);
end

for i = 1:frames
    weight(:,:,i) = edge(Im(:,:,i), 'sobel', []);     %%% Uses the sobel method of edge detection
    weight(:,:,i) = imdilate(weight(:,:,i), se1);    
    weight(:,:,i) = padarray(weight(3:end-2, 3:end-2,i), [2 2]); %%% Exclude image boundary pixels from processing by creating a padding array
end


if frames == 1
    [restoredIm, PSF] = deconvblind(Im, initial_PSF, 10,[], double(weight(:,:,i)));
    [counts, x] = imhist(restoredIm, 65535);
    [~, pos] = max(counts);
else
    for i = 1:frames
        [restoredIm(:,:,i), PSF(:,:,i)] = deconvblind(Im(:,:,i), initial_PSF, 10,[], double(weight(:,:,i)));
        [counts(:,i), x(:,i)] = imhist(restoredIm(:,:,i), 65535);
        [~, pos(i)] = max(counts(:,i));
    end
end
    
if routed == 0
    subplot(sub1,sub2,2); surf(PSF); title('Recovered PSF from deconvolution');
    subplot(sub1,sub2,3); imshow(restoredIm(:,:,currentframe), [pos 200]);
else
    axes(gui_SpineSegmentation.handles.Image_Axes);
    imshow(restoredIm(:,:,currentframe), [])
    if pauseopt == 1
        pause
    else
    end
    figure(h);
end

%% Background subtraction

waitbar(2/steps, h, 'Background subtracting...'); 

for i = 1:frames
    subtractIm(:,:,i) = restoredIm(:,:,i)-pos(i);
end

subtractIm(subtractIm<0) = 0;

if routed == 0
    subplot(sub1,sub2,4); imshow(restoredIm, [pos 200]); title('Restored im. from deconv.');
else
    axes(gui_SpineSegmentation.handles.Image_Axes);
    imshow(subtractIm(:,:,currentframe), [])
    if pauseopt == 1
        pause
    else
    end
    figure(h);
end

%% Weight array %%

%%% Create a weight array to exclude areas of high contrast (reduces
%%% 'ringing'). Examine the resulting weight array to get a better idea of
%%% how to better approximate the initial PSF for a second pass at
%%% deconvolution.

waitbar(3/steps, h, 'Creating weight array...');

se2 = strel('disk', 1);             %%% Created a structured element for image dilation

for i = 1:frames
    weight(:,:,i) = edge(Im(:,:,i), 'sobel', []);     %%% Uses the sobel method of edge detection
    weight(:,:,i) = imdilate(weight(:,:,i), se2);    
    weight(:,:,i) = padarray(weight(3:end-2, 3:end-2,i), [2 2]); %%% Exclude image boundary pixels from processing by creating a padding array
end

if routed == 0
    subplot(sub1,sub2,5); imshow(weight);
    title('Weighted Array');
else
    axes(gui_SpineSegmentation.handles.Image_Axes);
    imshow(weight(:,:,currentframe), [])
    if pauseopt == 1
        pause
    else
    end
    figure(h);
end

%% Use the PSF returned from the first pass of deconvolution to perform a second round of deconvolution

waitbar(4/steps, h, '2nd blind deconvolution...');

PSF(PSF<0.01) = 0;

for i = 1:frames
    [restoredIm2(:,:,i), PSF2(:,:,i)] = deconvblind(restoredIm(:,:,i), PSF(:,:,i), 10, [], double(weight(:,:,i)));
    [counts(:,i), x(:,i)] = imhist(restoredIm2(:,:,i), 65535);
    [val(i), pos(i)] = max(counts(:,i));
    restoredIm2(:,:,i) = restoredIm2(:,:,i)-pos(i); %%% Background correction
end

restoredIm2(restoredIm2<0) = 0;

if routed == 0
    subplot(sub1,sub2,6); surf(PSF2); title('Refined PSF');
    [counts, x] = imhist(restoredIm2, 65535);
    [~, pos] = max(counts);
    subplot(sub1,sub2,7); imshow(restoredIm2, [pos 200]); title('Second deconv.');
else
    axes(gui_SpineSegmentation.handles.Image_Axes);
    for i = 1:frames
        [counts(:,i), x(:,i)] = imhist(restoredIm2(:,:,i), 65535);
        [~, pos(i)] = max(counts(:,i));
    end
    imshow(restoredIm2(:,:,currentframe), [pos(currentframe) 200])
    if pauseopt == 1
        pause
    else
    end
    figure(h);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unevenness correction
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% f_c(x) = f(x) - k_c * F(x)
%%% where F(x) is a smoothed version of f(x), k_c denotes the correction
%%% coefficient, and f_c(x) denotes the corrected version

waitbar(5/steps, h, 'Unevenness correction...');

filt = fspecial('gaussian', GaussFilt_size);
for i = 1:frames
    smoothed(:,:,i) = imfilter(restoredIm2(:,:,i), filt);
    uneven_corr_Im(:,:,i) = restoredIm2(:,:,i) - 0.5*smoothed(:,:,i);
end


% Proc_Image = uneven_corr_Im;

if routed == 0
    subplot(sub1,sub2,8); imshow(uneven_corr_Im, [pos 200]); title('Smoothed & uneven corr')
else
    axes(gui_SpineSegmentation.handles.Image_Axes);
    imshow(uneven_corr_Im(:,:,currentframe), [pos(currentframe) 200])
    if pauseopt == 1
        pause
    else
    end
    figure(h);
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Reduce shot noise by applying median filter

waitbar(6/steps, h, 'Applying median filter...');

for i = 1:frames
    med_filt(:,:,i) = medfilt2(uneven_corr_Im(:,:,i), [MedFilt_size MedFilt_size]);
end

if routed == 0
    subplot(sub1,sub2,9); imshow(med_filt, [pos 200]); title('Median Filtered')
else
    axes(gui_SpineSegmentation.handles.Image_Axes);
    imshow(med_filt(:,:,currentframe), []);
    if pauseopt == 1
        pause
    else
    end
    figure(h);
end



%% Binarization %%%


waitbar(7/steps, h, 'Binarizing...');

counts = [];
x = [];
pos = [];

counts = [];
x = [];
pos = [];

%%% Apply a 2d interpolation to clean up the image

med_filt = double(med_filt);

for i = 1:frames
    med_filt(:,:,i) = imresize(interp2(med_filt(:,:,i),2),1/4);
end

bw = double(med_filt>mean(med_filt(:)));
bw = logical(bw);

if routed == 0
figure; imshow(bw);
else
end

% Proc_Image = bw;


%% Blob analysis

waitbar(8/steps, h, 'Blob analysis...')

h_blob = vision.BlobAnalysis('AreaOutputPort', true, 'BoundingBoxOutputPort', true, 'OutputDataType', 'double', 'MinimumBlobArea', MinBlob, 'MaximumBlobArea', MaxBlob, 'LabelMatrixOutputPort', true);

for i = 1:frames
    [~,~,~, LabelMatrix(:,:,i)] = step(h_blob, bw(:,:,i));
end

%% Final Data

Proc_Image = med_filt;
LabelMat = logical(LabelMatrix);

close(h);

end

